---
typora-root-url: .
typora-copy-images-to: ..\assets\img
---

# java多线程

## 一、线程基础概念

**线程（thread）**是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程，但轻量进程更多指内核线程，而把用户线程称为线程。

 

**线程是独立调度和分派的基本单位**。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。

 

**线程和进程的区别：**进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。

 

**线程的状态**：新建、可运行、阻塞、无限期等待、限期等待、死亡

 

## 二、如何使用线程

 

1. 实现runnable接口
2. 实现Callable接口
3. 继承Thread类

 

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

 

**实现接口 VS 继承 Thread**

实现接口会更好一些，因为：Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；类可能只要求可执行就行，继承整个 Thread 类开销过大。

 

## 三、线程池

 

**线程池：**线程池管理一个 工作者线程的同构池(homogeneous pool)。线程池是与工作队列(work queue)紧密绑定的。所谓**工作队列**，其作用是持有所有等待执行的任务。工作者线程的生活从此轻松起来:它从工作队列中获取下一个任务，执行它，然后回来继续等待另-一个线程。

 

类库提供了一个灵活的线程池实现和一些有用的预设配置。你可以通过调用Executors中的某个静态工厂方法来创建一个线程池:

1. **newFixedThreadPool**创建一个**定长**的线程池，每当提交-一个任      务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化(如果一个线程由于非预期的Except      ion而结束，线程池会补充-一个新的线程)。
2. **newCachedThreadPool**创建-个**可缓存**的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活地回收空闲的线程，当需求增加时，它可以灵活地添加新的线程，而并不会对池的长度作任何限制。
3. **newSingleThreadExecutor**创建一个 **单线程化**的executor,它只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它。executor会保证任务依照任务队列所规定的顺序(FIFO,      LIFO, 优先级)执行。
4. **newScheduledThreadPool**创建一个**定长**的线程池，而且支持**定时**的以及周期性的任务执行，类似于Timer      。

 

## 四、线程同步

 

Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。

 

**比较**

1. **锁的实现**：synchronized 是 JVM      实现的，而 ReentrantLock 是 JDK 实现的。
2. **性能**：新版本 Java 对 synchronized      进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。
3. **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock      可中断，而 synchronized 不行。
4. **公平锁**：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized      中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
5. **锁绑定多个条件**：一个 ReentrantLock 可以同时绑定多个      Condition 对象。

 

**使用选择**：除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

 

## 五、线程协作

 

**1、join（）**

在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

 

**2、wait() notify() notifyAll()**

- 它们都属于 Object 的一部分，而不属于 Thread。
- 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出      IllegalMonitorStateException。
- 使用 wait()      挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者      notifyAll() 来唤醒挂起的线程，造成死锁。

 

**3、wait() 和 sleep() 的区别**

- wait() 是 Object 的方法，而 sleep() 是      Thread 的静态方法；
- wait() 会释放锁，sleep() 不会。

 

**4、await() signal() signalAll()**

java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

 

## 六、JUC

**CountDownLatch**

1. 一个灵活的闭锁实现，允许一个或多个线程等待一个事件集的发生。
2. 闭锁的状态包括一个计数器，初始化为-一个正数，用来表现需要等待的事件数。
3. countDown      方法对计数器做减操作，表示一个事件已经发生了，
4. await方法等待计数器达到零，此时所有需要等待的事件都已发生。
5. 如果计数器入口时值为非零，await会一直阻塞直到计数器为零，或者等待线程中断以及超时。

 

**CyclicBarrier**

1. 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。
2. 和 CountdownLatch      相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await()      方法而在等待的线程才能继续执行。
3. CyclicBarrier 和 CountdownLatch      的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

 

**Semaphore**

Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。

 

**FutureTask**

FutureTask 的实现描述了一个抽象的可携带结果的计算 。FutureTask 的计算是通过Callable实现的，它等价于一个可携带结果的Runnable,并且有3个状态:等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦FutureTask进入完成状态，它会永远停止在这个状态上。

 

**BlockingQueue**

提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。

 

**ForkJoin**

- 主要用于并行计算中，和 MapReduce      原理类似，都是把大的计算任务拆分成多个小任务并行计算。
- ForkJoin 使用 ForkJoinPool      来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。
- ForkJoinPool 实现了工作窃取算法来提高 CPU      的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2      从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2      来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。

 

## 七、java内存模型

### 主内存与工作内存

![Thread  Thread  Thread  Thread  T f'FPF  T f'FPF  T f'FPF  T f'FPF  Load  Store  cyC2018 ](file:///C:/Users/13055/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。

线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。

##  

### 内存模型三大特性

1. **原子性：**Java 内存模型保证了      read、load、use、assign、store、write、lock 和 unlock  操作具有原子性，例如对一个 int 类型的变量执行 assign      赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64      位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write      操作可以不具备原子性。

![load  use  Thread  assign  read  store  write  cyC2018 ](file:///C:/Users/13055/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

1. **可见性：**可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java      内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

主要有三种实现可见性的方式：

- volatile
- synchronized，对一个变量执行 unlock      操作之前，必须把变量值同步回主内存。
- final，被 final      关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见      final 字段的值。

1. **有序性：**在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在      Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

## 八、线程安全

 

**什么是线程安全？**

多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。

 

**线程安全的实现方式**

1. 不可变对象天然安全
2. 互斥同步实现
3. 非阻塞同步
4. 无同步方案

 

### 1、不可变

不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。

 

不可变的类型：

- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 Long 和 Double      等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和      AtomicLong 则是可变的。

 

### 2、互斥同步实现

synchronized 和 ReentrantLock。

 

### 3、非阻塞同步

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

 

**CAS：**随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。

 

JUC包中的原子变量系列底层都是调用了Unsafe类的CAS操作。

 

**ABA**：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。

 

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

 

### 4、无同步方案

 

**栈封闭：**多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。

 

**线程本地存储：**如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

 

**可重入代码：**这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

 

## 九、锁优化（JVM对synchronized的优化）

 

### 自适应自旋锁

互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。

 

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

 

在 JDK 1.6 中引入了**自适应**的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。

 

### 锁消除

锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。

 

锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。

 

### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

 

如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

 

### 轻量级锁

JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）

 

轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

 

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

 

如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

 

### 偏向锁

偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

 

当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

 

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

 

## 总结

- **可变状态：**所有并发问题都归结为如何协调访问并发状态。可变状态越少，保证线程安全就越容易。
- 尽量将城声明为 final类型，除非它们的需要是可变的。
- 不可变对象天生是线程安全的。
- 不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享。
- 封装使管理复杂度变得更可行。
- 你固然可以用存储于全局变量的数据来写一个线程安全类。但是你为什么要这样做?在对象中装封数据，让它们能够更加容易地保持不变;在对象中封装同步，使它能够更容易地遵守同步策略。
- 用锁来守护每一个可变变量。
- 对同一不变约束中的所有变量都使用相同的锁。
- 在运行复合操作期间持有锁.
- 在非同步的多线程情况下，访问可变变量的程序是存在隐患的。
- 在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的。
- 文档化你的同步策略。

 

 

## 参考文献：

1. [百度百科](https://baike.baidu.com/item/线程)
2. [CS-Notes博客](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发)
3. 《java并发编程实战》